@config manual_fold : false

// === EXERCISE D : binary search trees ===
// 
// In this exercise, we go through a more intewsing
// data structure. In particular, we go through a
// binary search tree.
//
// The binary search tree comprises a number of
// components:
//   1. key (which is an Int value for this exercise)
//   2. left subtree
//   3. right subtree
// All keys in the left subtree must be less than the key,
// and all keys in the right subtree must be greater than
// the key. This wsriction implies there are no 
// duplicate keys in any given binary search tree.
//
// === PREDICATES ===
//
// Before setting up the binary search tree
// predicate, we must be able to express the following
// properties:
//   1. There are no duplicate key elements in a tree
//   2. All keys in the left subtree are strictly less
//      than the key on the root tree
//   3. All keys in the right subtree are strictly
//      greater than the key on the root tree.
// There are many ways to express this property -- but
// for this exercise, we will express these using
// lists.  
//?? Note that folding the bst predicate consumes
//? the pure predicates. To ensure we can also
//? fold the copied binary search tree, we need
//? to duplicate the remaining pure predicates.
//?? To duplicate the pure predicates, we need to
//? be able to refer to the logical variables.
//? The [[ assert {bind: ...} ... ]] tactic will
//? come in handy.
//?? You may find the [[ assert {bind: ... } ]]
//? tactic helpful to label the logical 
//? variables.
//?? Consider how the #vs looks at this point.
//? What can you say about t ∈ #vs?
//?? If a < t and list_lt(vs, t), what does this
//? say about a ∈ vs? Like what about the case
//? where a > t and list_gt(vs, t)?
//?? You may find the [[ assert {bind: ... } ]]
//? tactic helpful to label the logical 
//? variables.
//?? x <= x1 for all x1 ∈ S1 /\ 
//? x <  x2 for all x2 ∈ S2 ==> 
//? x <= x3 for all x3 ∈ S1 ∪ S2
//?? Currently, the structure of the tree at this
//? state is as follows:
//?       #k
//?       /  \
//?     l    r
//? ...where l != null, and #vsl is the list
//? of elements in the subtree pointed by l.
//? The recursive call to BSTFindMin(l) returns
//? list_member(#vsl, min, true) and 
//? list_min(#vsl, min). What now remains
//? is to show how min relates to #k and
//? and the keys in the subtree pointed by r.
//?? min <= s for all s ∈ S /\ 
//?   k >  s for all s ∈ S ==>
//? min <= s for all s ∈ {k} ∪ S 

// We have the list_member predicate, which should be
// familiar from the singly-linked list exercises.
predicate list_member(+vs, +v, r : Bool){
  (vs == []) * (r == false);
  (vs == v :: #ws) * (r == true);
  (vs == #v :: #ws) * (#v != v) * list_member(#ws, v, r)
}

// We also have the list_gt and list_lt predicates.
// list_lt(vs, v) states v < v' for all v' ∈ vs
// list_gt(vs, v) states v > v' for all v' ∈ vs
predicate list_gt(+vs, +v : Int){
  (vs == []);
  (vs == #v :: #ws) * (#v < v) * list_gt(#ws, v)
}

predicate list_lt(+vs, +v : Int){
  (vs == []);
  (vs == #v :: #ws) * (#v > v) * list_lt(#ws, v)
}

// ...and now we have the bst predicate.
// In the base case, we have the empty tree.
// In the inductive case, we have the following:
//   - x -b> #v, #l, #r
//     a ternary cell predicate, where
//     + #v is the key
//     + #l points to the left subtree
//     + #r points to the right subtree
//   - bst(#l, #vsl), the left subtree
//   - bst(#r, #vsr), the right subtree
//   - vs == #vsl @ [#v] @ #vsr
//     the 'keys' in the binary search tree pointed
//     by x, where
//     + #v is the key
//     + #vsl is the list of keys in subtree pointed
//       by #l,
//     + #vsr is the list of keys in subtree pointed
//       by #r
//   - list_member(#vsl, #v, false)
//     a predicate stating that duplicates of #v
//     cannot exist in subtree pointed by #l
//   - list_member(#vsr, #v, false)
//     same as above for the right subtree
//   - list_gt(#vsl, #v), a predicate stating that
//     that the key #k is strictly greater than all
//     keys in the subtree pointed by #l
//   - list_gt(#vsr, #v), a predicate stating that
//     that the key #k is strictly less than all
//     keys in the subtree pointed by #r
predicate bst(+x, vs : List) {
  // Empty Node
  (x == null) * (vs == []);
  (x -b> #v, #l, #r) * bst(#l, #vsl) * bst(#r, #vsr) *
  (vs == (#vsl @ [#v] @ #vsr)) *
  list_member(#vsl, #v, false) * 
  list_member(#vsr, #v, false) *
  list_gt(#vsl, #v) *
  list_lt(#vsr, #v)
}

// We also have a predicate list_min, which states
// given list_min(vs, v), v <= v' for all v' ∈ vs
// This might be better thought of as list_lte,
// i.e. the element v is less than or equal to all
// elements in vs. This is not used for the binary
// search tree predicate but is used elsewhere.
predicate list_min(+vs, +v : Int){
  (vs == []);
  (vs == #v :: #ws) * (v <= #v) * list_min(#ws, v)
}

// === LEMMAS ===
// We do not go through the lemmas in great detail,
// but we provide a number of lemmas that you may
// find useful for the purpose of completing this
// exercise.

lemma list_member_prepend_neq {
  statement:
    forall vs, k, v.
      list_member(vs, v, #r) * (k != v) |- list_member(k::vs, v, #r)
}

lemma list_member_concat {
  statement:
    forall vs1, vs2, v.
      list_member(vs1, v, true) |- list_member(vs1 @ vs2, v, true)
}

lemma list_member_concat_gen {
  statement:
    forall vs1, vs2, v.
      list_member(vs1, v, #r1) * list_member(vs2, v, #r2) |- list_member(vs1 @ vs2, v, (#r1 || #r2))
}

// Note: lemmas with emp as an assumption essentially
//       implies the lemma does not have an assumption
lemma list_member_front_helper {
  statement:
    forall v, vs.
      emp |- list_member(v::vs, v, true)
}

lemma list_member_mid {
  statement:
    forall v, vsl, vsr.
      emp |- list_member(vsl @ [v] @ vsr, v, true)
}

lemma min_merge {
  statement:
    forall min, vsl, vsr.
      list_min(vsl, min) * list_lt(vsr, min) |- list_min(vsl@vsr, min) * list_lt(vsr, min)
}

lemma min_merge_k {
  statement:
    forall min, k, vsl, vsr.
      list_min(vsl@[k], min) * list_lt(vsr, k) |- list_min(vsl@[k]@vsr, min) * list_lt(vsr, k)
}

lemma min_gt_append {
  statement:
    forall min, k, vs.
      list_min(vs, min) * list_gt(vs, k) * (vs != []) |- list_min(vs @ [k], min) * list_gt(vs, k)
}

lemma min_include {
  statement:
    forall k, vs.
      list_min(vs, k) |- list_min(k::vs, k)
}

// Note: pure predicates can be duplicated -- you may
// find a number of these 'duplicate' lemmas useful
// before folding a predicate and consuming the pure
// predicates.
lemma min_duplicate {
  statement:
    forall vs, k.
      list_min(vs, k) |- list_min(vs, k) * list_min(vs, k)
}

lemma lt_duplicate {
  statement:
    forall vs, k.
      list_lt(vs, k) |- list_lt(vs, k) * list_lt(vs, k)
}

lemma gt_duplicate {
  statement:
    forall vs, k.
      list_gt(vs, k) |- list_gt(vs, k) * list_gt(vs, k)
}

lemma member_duplicate {
  statement:
    forall vs, k, r.
      list_member(vs, k, r) |- list_member(vs, k, r) * list_member(vs, k, r)
}

lemma list_member_gt {
  statement:
    forall a, k, vs.
      (k < a) * list_gt(vs, k) |- list_member(vs, a, false) * list_gt(vs, k)
}

lemma list_member_lt {
  statement:
    forall a, k, vs.
      (a < k) * list_lt(vs, k) |- list_member(vs, a, false) * list_lt(vs, k)
}

{ (v == #v) * (v : Int) }
function BSTAllocateLeaf(v) {
  t := new(3);
  [t] := v;
  return t
}
{ bst(ret, [#v]) }

// 01. copying a binary search tree (MEDIUM)
//     This function creates a copy of a given
//     binary search tree.
{ (x == #x) * bst(#x, #vs) }
function BSTCopy(x) {
  if(x != null) {
    //-[[ assert {bind: #k, #kl, #kr} (x -b> #k, #kl, #kr) ]];
    //-[[ assert {bind: #vsl, #vsr}
    //-        bst(#kl, #vsl) * bst(#kr, #vsr) ]];
    y := new(3);
    t := [x];
    [y] := t;
    t := [x + 1];
    t := BSTCopy(t);
    [y + 1] := t;
    t := [x + 2];
    t := BSTCopy(t);
    [y + 2] := t;
    //+// Hints 1 & 2 may help here
    //?? Note that folding the bst predicate consumes
    //? the pure predicates. To ensure we can also
    //? fold the copied binary search tree, we need
    //? to duplicate the remaining pure predicates.
    //?? To duplicate the pure predicates, we need to
    //? be able to refer to the logical variables.
    //? The [[ assert {bind: ...} ... ]] tactic will
    //? come in handy.
    //-[[ apply lt_duplicate(#vsr, #k) ]];
    //-[[ apply gt_duplicate(#vsl, #k) ]];
    //-[[ apply member_duplicate(#vsl, #k, false) ]];
    //-[[ apply member_duplicate(#vsr, #k, false) ]];
    [[ fold bst(y, #vs) ]]
  } else {
    y := null
  };
  return y
}
{ bst(#x, #vs) * bst(ret, #vs) }

// 02. Searching for a value in a BST (MEDIUM)
{ (x == #x) * (a == #a) * bst(#x, #vs) * a : Int }
function BSTSearch(x, a) {
  r := false;
  [[ unfold bst(#x, #vs) ]];
  if(x != null) {
    //+// Hint 3 may help here
    //?? You may find the [[ assert {bind: ... } ]]
    //? tactic helpful to label the logical 
    //? variables.
    //-[[ assert {bind: #k, #kl, #kr, #vsl, #vsr} (x -b> #k, #kl, #kr) *
    //-         bst(#kl, #vsl) * bst(#kr, #vsr) *
    //-         list_gt(#vsl, #k) * list_lt(#vsr, #k) *
    //-         list_member(#vsl, #k, false) * list_member(#vsr, #k, false) ]];
    t := [x];
    if(a == t) {
      //+// Hint 4 may help here
      //?? Consider how the #vs looks at this point.
      //? What can you say about t ∈ #vs?
      //-[[ apply list_member_mid(a, #vsl, #vsr) ]];
      r := true
    } else {
      if(a < t) {
        //+// Hint 5 may help here
	//?? if a < t and list_lt(vs, t), what does this
        //? say about a ∈ vs? Like what about the case
        //? where a > t and list_gt(vs, t)?
        //-[[ apply list_member_lt(#a, #k, #vsr) ]];
        t := [x + 1];
        r := BSTSearch(t, a)
      } else {
        //+// Hint 5 may help here
	//?? if a < t and list_lt(vs, t), what does this
        //? say about a ∈ vs? Like what about the case
        //? where a > t and list_gt(vs, t)?
        //-[[ apply list_member_gt(#a, #k, #vsl) ]];
        t := [x + 2];
        r := BSTSearch(t, a)
      };
      //-[[ apply list_member_prepend_neq(#vsr, #k, #a) ]];
      //-[[ apply list_member_concat_gen(#vsl, #k::#vsr, #a) ]]
    }
  } else {
    [[ fold list_member([], a, false) ]];
    skip
  };
  return r
}
{ bst(#x, #vs) * list_member(#vs, #a, ret) }

// 03. obtaining the minimum of a binary search tree (HARD)
//     This function returns the minimum key in a
//     given binary serach tree. In other words,
//     the function returns the left-most key in the
//     tree. Note that the precondition states the 
//     given tree is non-empty.
{ (x == #x) * (#x != null) * bst(#x, #vs) }
function BSTFindMin(x) {
  //+// Hint 6 may help here
  //?? You may find the [[ assert {bind: ... } ]]
  //? tactic helpful to label the logical 
  //? variables.
  //-[[ assert {bind: #k, #kl, #kr, #vsl, #vsr} (x -b> #k, #kl, #kr) *
  //-        bst(#kl, #vsl) * bst(#kr, #vsr) *
  //-        list_gt(#vsl, #k) * list_lt(#vsr, #k) *
  //-        list_member(#vsl, #k, false) * list_member(#vsr, #k, false) ]];
  l := [x + 1];
  if (l == null) {
    //-[[ apply min_include(#k, #vsl) ]];
    min := [x];
    //+// Hint 7 may help here
    //?? x <= x1 for all x1 ∈ S1 /\ 
    //? x <  x2 for all x2 ∈ S2 ==> 
    //? x <= x3 for all x3 ∈ S1 ∪ S2
    //-[[ apply min_merge(#k, #k::#vsl, #vsr) ]];
    //-[[ apply list_member_concat(#k::#vsl, #vsr, #k) ]]
  } else {
    min := BSTFindMin(l);
    //+// Hint 8, 9 may help here
    //?? Currently, the structure of the tree at this
    //? state is as follows:
    //?     #k
    //?    /  \
    //?   l    r
    //? ...where l != null, and #vsl is the list
    //? of elements in the subtree pointed by l.
    //? The recursive call to BSTFindMin(l) returns
    //? list_member(#vsl, min, true) and 
    //? list_min(#vsl, min). What now remains
    //? is to show how min relates to #k and
    //? and the keys in the subtree pointed by r.
    //?? min <= s for all s ∈ S /\ 
    //? k >  s for all s ∈ S ==>
    //? min <= s for all s ∈ {k} ∪ S 
    //-[[ apply min_gt_append(min, #k, #vsl) ]];
    //-[[ apply min_merge_k(min, #k, #vsl, #vsr) ]];
    //-[[ apply list_member_concat_gen(#vsl, [#k], min)]];
    //-[[ apply list_member_concat(#vsl@[#k], #vsr, min) ]]
  };
  [[ fold bst(#x, #vs) ]];
  return min
}
{ (#x != null) * bst(#x, #vs) * list_member(#vs, ret, true) * list_min(#vs, ret) }
