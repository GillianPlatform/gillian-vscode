predicate EC(+x, p, s : Set) {
	(s == -{p}-) * (x == p) * p -> p;
	(x -> #a) * (p != x) *
	(#a != x) * EC(#a, p, #s) *
  (#a -e- s) * (s == #s -u- -{x}-) *
	(!(x -e- #s))
}

predicate ECC(x, +p, s : Set) {
	(s == -{p}-) * (x == p);
	(x -> #a) * (p != x) *
	(#a != x) * ECC(#a, p, #s) *
  (#a -e- s) * (s == #s -u- -{x}-) *
	(!(x -e- #s))
}

lemma EC_rep_downgrade {
	statement:
		forall x, p, s.
			EC(x, p, s) |- ECC(x, p, s)
	proof:
		unfold EC(x, p, s);
		if (p != x) {
			assert {bind: #a, #ss} ((x -> #a) * (s == #ss -u- -{x}-) * EC(#a, p, #ss));
			apply EC_rep_downgrade(#a, p, #ss);
			fold ECC(x, p, s)
		}
} 


lemma EC_rep_loc {
	statement:
		forall x, p, s.
			EC(x, p, s) |- ECC(x, p, s) * p -> p
	proof:
		unfold EC(x, p, s);
		if (x != p) {
			assert {bind: #a, #ss} ((x -> #a) * (s == #ss -u- -{x}-) * EC(#a, p, #ss));
			apply EC_rep_loc(#a, p, #ss);
			fold ECC(x, p, s)
		}
} 



{ (x == #x) * EC(#x, #p, #s) * (#x -e- #s) }
function UFRep(x) {
	next := [x];
	if (next == x) {
		r := x
	} else {
		r := UFRep(next)
	};
	return r
}
{ EC(#x, #p, #s) * (ret == #p) }

{ (x == #x) * (y == #y) * EC(#x, #px, #sx) * EC(#y, #py, #sy) * (#x -e- #sx) * (#y -e- #sy)}
function UFMerge(x, y) {
	px := UFRep(x);
	py := UFRep(y);
	[[ apply EC_rep_loc(#y, #py, #sy) ]];
	[py] := px;
	return px
}
{ EC(#x, #px, #sx -u- #sy) * (ret == #px) }