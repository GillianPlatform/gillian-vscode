//
// Standard over-approximating SLL predicate with contents
//
predicate SLLSet(+x, vs) {
  // Empty SLL
  (x == null) * (vs == -{}-);
  // One SLL node and the rest
  (x -b> #v, #next) * SLLSet(#next, #vs) *
  (vs == -{#v}- -u- #vs)
}

predicate list_member(+vs, +v, r : Bool){
  (vs == []) * (r == false);
  (vs == v :: #rest) * (r == true);
  (vs == #v :: #rest) * (#v != v) * list_member(#rest, v, r)
}

lemma list_member_prepend {
  statement:
    forall vs, k, v.
      list_member(vs, v, true) |- list_member(k::vs, v, true)

  proof:
    if(#vs == []) {
      unfold list_member(#vs, #v, true)
    } else {
      unfold list_member(#vs, #v, true);
      assert {bind: #u, #vss} (#vs == #u::#vss);
      fold list_member(#vs, #v, true);
      apply list_member_prepend(#vs, #k, #v)
    } 
}

lemma list_member_prepend_neq {
  statement:
    forall vs, k, v.
      list_member(vs, v, #r) * (k != v) |- list_member(k::vs, v, #r)

  proof:
    if(#vs == []) {
      unfold list_member(#vs, #v, #r)
    } else {
      unfold list_member(#vs, #v, #r);
      assert {bind: #u, #vss} (#vs == #u::#vss);
      fold list_member(#vs, #v, #r);
      apply list_member_prepend_neq(#vs, #k, #v)
    } 
}

lemma list_member_concat {
  statement:
    forall vs1, vs2, v.
      list_member(vs1, v, true) |- list_member(vs1 @ vs2, v, true)

  proof:
    if(vs2 != []) {
      assert {bind: #v2, #vss2} (#vs2 == #v2::#vss2);
      apply list_member_concat(#vs1, [#v2], #v);
      apply list_member_concat(#vs1@[#v2], #vss2, #v)
    }
}

lemma list_member_concat_false {
  statement:
    forall vs1, vs2, v.
      list_member(vs1, v, #r) * list_member(vs2, v, false) |- list_member(vs1 @ vs2, v, #r)
  proof:
    if (vs2 != []) {
      unfold list_member(#vs2, #v, false);
      assert {bind: #vr, #vssr} (#vs2 == #vr::#vssr) * list_member(#vssr, #v, false);
      fold list_member([], #v, false);
      fold list_member([#vr], #v, false);
      apply list_member_concat_false(#vs1, [#vr], #v);
      apply list_member_concat_false(#vs1@[#vr], #vssr, #v)
    }
}

lemma list_member_concat_false_2 {
  statement:
    forall vs1, vs2, v.
      list_member(vs1, v, false) * list_member(vs2, v, #r) |- list_member(vs1 @ vs2, v, #r)
  proof:
    if (vs1 != []) {
      unfold list_member(#vs1, #v, false);
      assert {bind: #vl, #vssl} (#vs1 == #vl::#vssl) * list_member(#vssl, #v, false);
      apply list_member_concat_false_2(#vssl, #vs2, #v);
      apply list_member_concat_false_2([#vl], #vssl@#vs2, #v)
    }
}

lemma list_member_front {
  statement:
    forall v, vs.
      emp |- list_member(v::vs, v, true)

  proof:
    unfold list_member(v::vs, v, true)
}

predicate list_gt(+vs, +v : Int){
  (vs == []);
  (vs == #v :: #rest) * (#v < v) * list_gt(#rest, v)
}

predicate list_lt(+vs, +v : Int){
  (vs == []);
  (vs == #v :: #rest) * (#v > v) * list_lt(#rest, v)
}

predicate list_min(+vs, +v : Int){
  (vs == []);
  (vs == #v :: #rest) * (v <= #v) * list_min(#rest, v)
}

predicate list_to_set(+l : List, s : Set) {
  (l == []) * (s == -{}-);
  (l == #v :: #vs) * (s == -{#v}- -u- #es) * list_to_set(#vs, #es)
}

lemma min_merge {
  statement:
    forall min, vsl, vsr.
      list_min(vsl, min) * list_lt(vsr, min) |- list_min(vsl@vsr, min) * list_lt(vsr, min)
  proof:
    if(vsr != []) {
      unfold list_lt(#vsr, #min);
      assert {bind: #vr, #vssr} (#vsr == #vr::#vssr) * list_lt(#vssr, #min);
      fold list_lt([], #min);
      fold list_lt([#vr], #min);
      apply min_merge(#min, #vsl, [#vr]);
      apply min_merge(#min, #vsl@[#vr], #vssr);
      fold list_lt(#vsr, #min)
    } 
}

lemma min_merge_k {
  statement:
    forall min, k, vsl, vsr.
      list_min(k::vsl, min) * list_lt(vsr, k) |- list_min(k::vsl@vsr, min) * list_lt(vsr, k)
  proof:
    if(vsr != []) {
      unfold list_lt(#vsr, #k);
      assert {bind: #vr, #vssr} (#vsr == #vr::#vssr) * list_lt(#vssr, #k);
      fold list_lt([], #k);
      fold list_lt([#vr], #k);
      apply min_merge_k(#min, #k, #vsl, [#vr]);
      apply min_merge_k(#min, #k, #vsl@[#vr], #vssr);
      fold list_lt(#vsr, #k)
    } 
}

lemma min_gt_append {
  statement:
    forall min, k, vs.
      list_min(vs, min) * list_gt(vs, k) * (vs != []) |- list_min(k::vs, min) * list_gt(vs, k)
  proof:
    if(#vs != []) {
      unfold list_min(#vs, #min);
      unfold list_gt(#vs, #k)
     }
}

lemma min_include {
  statement:
    forall k, vs.
      list_min(vs, k) |- list_min(k::vs, k)
    proof:
      if(true) {}
}

lemma min_duplicate {
  statement:
    forall vs, k.
      list_min(vs, k) |- list_min(vs, k) * list_min(vs, k)
  proof:
    unfold list_min(vs, k);
    if(vs != []) {
      assert {bind: #v, #vss} (vs == #v::#vss) * list_min(#vss, k);
      apply min_duplicate(#vss, k)
  }
}

lemma lt_duplicate {
  statement:
    forall vs, k.
      list_lt(vs, k) |- list_lt(vs, k) * list_lt(vs, k)
  proof:
    unfold list_lt(vs, k);
    if(vs != []) {
      assert {bind: #v, #vss} (vs == #v::#vss) * list_lt(#vss, k);
      apply lt_duplicate(#vss, k)
  }
}

lemma gt_duplicate {
  statement:
    forall vs, k.
      list_gt(vs, k) |- list_gt(vs, k) * list_gt(vs, k)
  proof:
    unfold list_gt(vs, k);
    if(vs != []) {
      assert {bind: #v, #vss} (vs == #v::#vss) * list_gt(#vss, k);
      apply gt_duplicate(#vss, k)
  }
}

lemma member_duplicate {
  statement:
    forall vs, k, r.
      list_member(vs, k, r) |- list_member(vs, k, r) * list_member(vs, k, r)
  proof:
    unfold list_member(#vs, #k, #r);
    if (#vs != []) {
      assert {bind: #v, #vss} (#vs == #v::#vss);
      if (#v != #k) {
        apply member_duplicate(#vss, #k, #r)
      }
    }
}

lemma list_member_gt {
  statement:
    forall a, k, vs.
      (k < a) * list_gt(vs, k) |- list_member(vs, a, false) * list_gt(vs, k)
  proof:
    if(vs != []) {
      assert {bind: #v, #vss} (#vs == #v::#vss);
      unfold list_gt(#v::#vss, #k);
      apply list_member_gt(#a, #k, #vss)
    }
}

lemma list_member_lt {
  statement:
    forall a, k, vs.
      (a < k) * list_lt(vs, k) |- list_member(vs, a, false) * list_lt(vs, k)
  proof:
    if(vs != []) {
      assert {bind: #v, #vss} (#vs == #v::#vss);
      unfold list_lt(#v::#vss, #k);
      apply list_member_lt(#a, #k, #vss)
    }
}

predicate tree(+x, vs : Set) {
  // Empty Node
  (x == null) * (vs == -{}-);
  (x -b> #v, #l, #r) * tree(#l, #vl) * tree(#r, #vr) *
  (vs == (#vl -u- -{#v}-) -u- #vr) *
  (!(#v -e- #vl)) *
  (!(#v -e- #vr))
}

predicate bst(+x, vs : List) {
  // Empty Node
  (x == null) * (vs == []);
  (x -b> #v, #l, #r) * bst(#l, #vsl) * bst(#r, #vsr) *
  (vs == #v :: #vsl @ #vsr) *
  list_member(#vsl, #v, false) * 
  list_member(#vsr, #v, false) *
  list_gt(#vsl, #v) *
  list_lt(#vsr, #v)
}

{(x == #x) * (y == #y) * SLLSet(#x, #vx) * SLLSet(#y, #vy) }
function SLL_concat(x, y) {
  [[ unfold SLLSet(x, #vx) ]];
  if (x == null){
    x := y
  } else {
    t := [x + 1];
    z := SLL_concat(t, y);
    [x + 1] := z;
    [[ fold SLLSet(x, #vx -u- #vy) ]]
  };
  return x
}
{ SLLSet(ret,  #vx -u- #vy) }

{ (x == #x) * tree(x, #vs) }
function listify(x) {
  [[ unfold tree(x, #vs) ]];
  if (x == null) {
    r := null
  } else {
    a := [x]; l := [x + 1]; r := [x + 2];
    y := listify(l);
    z := listify(r);
    y := SLL_concat(y, z);
    r := new(2); [r] := a; [r + 1] := y
  };
  [[ fold tree(x, #vs) ]];
  [[ fold SLLSet(r, #vs) ]];
  return r
}
{ tree(#x, #vs) * SLLSet(ret, #vs) }

{ (v == #v) }
function BSTAllocateLeaf(v) {
  assume_type(v, Int);
  t := new(3);
  [t] := v;
  [[ fold bst(null, []) ]];
  [[ fold bst(null, []) ]];
  [[ fold list_member([], #v, false)]];
  [[ fold list_member([], #v, false)]];
  [[ fold list_gt([], #v)]];
  [[ fold list_lt([], #v)]];
  [[ fold bst(t, [#v]) ]];
  return t
}
{ bst(ret, [#v]) }

{ (x == #x) * bst(#x, #vs) }
function BSTCopy(x) {
  [[ unfold bst(#x, #vs) ]];
  if(x != null) {
    [[ assert {bind: #k, #kl, #kr, #vsl, #vsr} (x -b> #k, #kl, #kr) *
            bst(#kl, #vsl) * bst(#kr, #vsr) *
            list_gt(#vsl, #k) * list_lt(#vsr, #k) *
            list_member(#vsl, #k, false) * list_member(#vsr, #k, false) ]];
    y := new(3);
    t := [x];
    [y] := t;
    t := [x + 1];
    t := BSTCopy(t);
    [y + 1] := t;
    t := [x + 2];
    t := BSTCopy(t);
    [y + 2] := t;
    [[ apply lt_duplicate(#vsr, #k) ]];
    [[ apply gt_duplicate(#vsl, #k) ]];
    [[ apply member_duplicate(#vsl, #k, false) ]];
    [[ apply member_duplicate(#vsr, #k, false) ]];
    [[ fold bst(y, #vs) ]]
  } else {
    y := null;
    [[ fold bst(y, []) ]]
  };
  [[ fold bst(#x, #vs) ]];
  return y
}
{ bst(#x, #vs) * bst(ret, #vs) }

{ (x == #x) * (a == #a) * bst(#x, #vs) }
function BSTSearch(x, a) {
  assume_type(a, Int);
  r := false;
  [[ unfold bst(#x, #vs) ]];
  if(x != null) {
    [[ assert {bind: #k, #kl, #kr, #vsl, #vsr} (x -b> #k, #kl, #kr) *
             bst(#kl, #vsl) * bst(#kr, #vsr) *
             list_gt(#vsl, #k) * list_lt(#vsr, #k) *
             list_member(#vsl, #k, false) * list_member(#vsr, #k, false) ]];
    t := [x];
    if(a == t) {
      [[ apply list_member_front(a, #vsl@#vsr) ]];
      r := true
    } else {
      if(a < t) {
        [[ apply list_member_lt(#a, #k, #vsr) ]];
        t := [x + 1];
        r := BSTSearch(t, a);
        [[ apply list_member_concat_false(#vsl, #vsr, #a) ]]
      } else {
        [[ apply list_member_gt(#a, #k, #vsl) ]];
        t := [x + 2];
        r := BSTSearch(t, a);
        [[ apply list_member_concat_false_2(#vsl, #vsr, #a) ]]
      };
      [[ apply list_member_prepend_neq(#vsl@#vsr, #k, #a) ]]
    }
  } else {
    [[ fold list_member([], a, false) ]];
    skip
  };
  [[ fold bst(#x, #vs) ]];
  return r
}
{ bst(#x, #vs) * list_member(#vs, #a, ret) }

{ (x == #x) * (#x != null) * bst(#x, #vs) }
function BSTFindMin(x) {
  [[ unfold bst(#x, #vs) ]];
  [[ assert {bind: #k, #kl, #kr, #vsl, #vsr} (x -b> #k, #kl, #kr) *
          bst(#kl, #vsl) * bst(#kr, #vsr) *
          list_gt(#vsl, #k) * list_lt(#vsr, #k) *
          list_member(#vsl, #k, false) * list_member(#vsr, #k, false) ]];
  l := [x + 1];
  if (l == null) {
    [[ unfold bst(#kl, #vsl) ]];
    [[ fold list_member(#k::#vsl, #k, true) ]];
    [[ fold list_min(#vsl, #k) ]];
    [[ apply min_include(#k, #vsl) ]];
    min := [x];
    [[ apply min_merge(#k, #k::#vsl, #vsr) ]];
    [[ apply list_member_concat(#k::#vsl, #vsr, #k) ]];
    [[ fold bst(#kl, #vsl) ]]
  } else {
    min := BSTFindMin(l);
    [[ unfold bst(#kl, #vsl)]];
    [[ apply min_gt_append(min, #k, #vsl) ]];
    [[ fold bst(#kl, #vsl)]];
    [[ apply min_merge_k(min, #k, #vsl, #vsr) ]];
    [[ apply list_member_prepend(#vsl, #k, min) ]];
    [[ apply list_member_concat(#k::#vsl, #vsr, min) ]]
  };
  [[ fold bst(#x, #vs) ]];
  return min
}
{ (#x != null) * bst(#x, #vs) * list_member(#vs, ret, true) * list_min(#vs, ret) }
