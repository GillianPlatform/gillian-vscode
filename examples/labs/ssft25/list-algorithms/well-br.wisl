
predicate SLL(+x, vs) {
  // Empty SLL
  (x == null) * (vs == []);
  // One SLL node and the rest
  (x -b> #v, #next) * SLL(#next, #vs) *
  (vs == #v :: #vs)
}

predicate SLLseg(+x, y, vs) {
  (x == y) * (vs == []);
  (x -b> #v, #next) * SLLseg(#next, y, #vs) * (vs == #v :: #vs)
}

lemma SLLseg_concat_SLL {
  statement:
    forall x, y.
      SLLseg(x, y, #vx) * SLL(y, #vy) |- SLL (x, #vx @ #vy)

  proof:
    unfold SLLseg(x, y, #vx);
    if (#vx != []){
      assert {bind: #nv, #nnext} (x -b> #nv, #nnext);
      apply SLLseg_concat_SLL(#nnext, y)
    }
}

//
// Lemma: a null-terminating SLLseg is an SLL
//
lemma SLLseg_to_SLL {
  statement:
    forall x.
      SLLseg(x, null, #vx) |- SLL(x, #vx)

  proof:
    unfold SLLseg(x, null, #vx);
    if (#vx != []){
      assert {bind: #nv, #nnext} (x -b> #nv, #nnext);
      apply SLLseg_to_SLL(#nnext)
    }
}

{ (v == #v) }
function SLL_allocate_node(v) {
  t := new(2);
  [t] := v;
  [[ fold SLL(null, []) ]];
  [[ fold SLL(t, [ #v ])]];
  return t
}
{ SLL(ret, [ #v ]) }

{ (x == #x) * (k == #k) * SLL(#x, #vs) }
function SLL_push(x, k) {
  z := SLL_allocate_node(k);
  [[ unfold SLL(z, [ #k ])]];
  [z + 1] := x;
  [[ fold SLL(z, #k :: #vs)]];
  return z
}
{ SLL(ret, #k :: #vs) }

{ (x == #x) * (x != null) * SLL(#x, #k :: #vs) }
function SLL_pop(x) {
  [[ unfold SLL(#x, #k :: #vs)]];
  r := new(2);
  k := [x];
  z := [x + 1];
  [r] := k;
  [r + 1] := z;
  return r
}
{ SLL(#z, #vs) * (ret == #r) * #r -b> #k, #z}

// Well bracked predicates

predicate ob(c : String) {
  ((c == "<") || (c == "["))
}

predicate cb(c : String) {
  ((c == ">") || (c == "]"))
}

predicate nb(c : String) {
  ((c != "<") /\ (c != ">") /\ (c != "[") /\ (c != "]"))
}

predicate bpair(c1 : String, c2 : String) {
  ((c1 == "<") /\ (c2 == ">") \/ ((c1 == "[") /\ (c2 == "]")))
}

predicate wbs(+a, +b) {
  (a == []) * (b == []);
  (a == #c :: #a) * ob(#c) * wbs(#a, #c :: b);
  (a == #c :: #a) * cb(#c) * (b == #d :: #b) * bpair(#d, #c) * wbs(#a, #b);
  (a == #c :: #a) * nb(#c) * wbs(#a, b)
}

predicate wb(+a) {
  wbs(a, [])
}

{ (x == #x) * SLL(#x, #a) * wb(#a) }
function wellBr(x) {	
  y := x; 
  s := null; 
  ok := true;
  [[ fold SLLseg(x, y, [])]];
  [[ fold SLL(s, [])]];
  [[ invariant {bind: ok, s, y, #a1, #a2, #b}
          SLLseg(x, y, #a1) * SLL(y, #a2) * SLL(s, #b) * (#a == #a1 @ #a2)
          * wbs(#a2, #b) * (ok == true)]];
  while (y != null && ok == true) {
    [[ unfold SLL(y, #a2)]];
    c := [y];
    [[ unfold wbs(#a2, #b)]];
    if ((c == "<") || (c == "[")) {
      s := SLL_push(s, c)
    } else {
      if ((c == ">") || (c == "]")) {
        if (s == null) { 
          ok := false 
        } else {
          r := SLL_pop(s);
          d := [r];
          s := [r + 1];
          bpair := ((d == "<") && (c == ">")) || ((d == "[") && (c == "]"));
          ok := (ok && bpair)
        }
      } else { 
        skip 
      }
    };
    y := [y + 1]
  };
  return (ok && (s == null))
}
{ SLL(x, #a) * wb(#a) * (ret == true) }