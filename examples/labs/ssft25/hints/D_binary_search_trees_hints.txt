Hint 1: Note that folding the bst predicate consumes
        the pure predicates. To ensure we can also
        fold the copied binary search tree, we need
        to duplicate the remaining pure predicates.
Hint 2: To duplicate the pure predicates, we need to
        be able to refer to the logical variables.
        The [[ assert {bind: ...} ... ]] tactic will
        come in handy.
Hint 3: You may find the [[ assert {bind: ... } ]]
        tactic helpful to label the logical 
        variables.
Hint 4: Consider how the #vs looks at this point.
        What can you say about t ∈ #vs?
Hint 5: if a < t and list_lt(vs, t), what does this
        say about a ∈ vs? Like what about the case
        where a > t and list_gt(vs, t)?
Hint 6: You may find the [[ assert {bind: ... } ]]
        tactic helpful to label the logical 
        variables.
Hint 7: x <= x1 for all x1 ∈ S1 /\ 
        x <  x2 for all x2 ∈ S2 ==> 
        x <= x3 for all x3 ∈ S1 ∪ S2
Hint 8: Currently, the structure of the tree at this
        state is as follows:
              #k
             /  \
            l    r
        ...where l != null, and #vsl is the list
        of elements in the subtree pointed by l.
        The recursive call to BSTFindMin(l) returns
        list_member(#vsl, min, true) and 
        list_min(#vsl, min). What now remains
        is to show how min relates to #k and
        and the keys in the subtree pointed by r.
Hint 9: min <= s for all s ∈ S /\ 
          k >  s for all s ∈ S ==>
        min <= s for all s ∈ {k} ∪ S 