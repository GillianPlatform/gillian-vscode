@config manual_fold : true

// === Apply tactic ===
// TODO: Give a tutorial using list_get as an example of how to use a lemma. This lemma is actually not required
// but makes the verification simpler. Helps to understand how apply works.

predicate list(+x, alpha) {
    (x == null) * (alpha == nil);
    (x -> #v, #z) * list(#z, #beta) * (alpha == #v::#beta)
}

predicate list_search(+vs, +i, v) {
  (vs == #v :: #vs) * (i == 1) * (v == #v);
  (vs == #v :: #vs) * (i != 1) * (i < len(vs)) * list_search(#vs, i - 1, v)
}

lemma search_not_null {
  statement:
    forall x, vs, i, r.
      list(x, vs) * list_search(vs, i, r) * (i != 0) |- list(x, vs) * list_search(vs, i, r) * (x != null)
  proof:
    unfold list_search(vs, i, r);
    unfold list(x, #vs);
    fold list(x, #vs);
    fold list_search(#vs, #i, #r)
}

{ (x == #x) * (i == #i) * (x != null) * list(x, #vs) * list_search(#vs, #i, #r) }
function list_get(x, i) {
  [[ unfold list(x, #vs)]];
  [[ unfold list_search(#vs, #i, #r)]];
  v := [x];
  next := [x + 1];
  if (i == 1) {
    r := v
  } else {
    i := i - 1;
    [[ assert {bind: #beta} list(next, #beta)]];
    [[ apply search_not_null(next, #beta, i, #r) ]];
    r := list_get(next, i)
  };
  [[ fold list(x, #vs)]];
  [[ fold list_search(#vs, #i, #r)]];
  return r
}
{ list(#x, #vs) * list_search(#vs, #i, #r) * (ret == #r) }

predicate l_member(+vs, +v, r : Bool){
  (vs == []) * (r == false);
  (vs == v :: #rest) * (r == true) * l_member(#rest, v, #mem);
  (vs == #v :: #rest) * (! (#v == v)) * l_member(#rest, v, r)
}

lemma list_member_create {
  statement:
    forall x, k, vs.
      list(x, vs) |- list(x, vs) * l_member(vs, k, #r)
  proof:
    unfold list(x, vs);
    if (x == null) {
      fold list(x, vs);
      fold l_member(vs, k, false)
    } else {
      assert {bind: #v, #beta} (#vs == #v :: #beta) * (x -> #v, #z);
      apply list_member_create(#z, k, #beta);
      if (#v == k) {
        fold l_member(vs, k, true)
      } else {
        fold l_member(vs, k, #r)
      }
    }
}

{ (x == #x) * (k == #k) * list(#x, #vs) }
function list_member(x, k){
  found := false;
  [[ unfold list(x, #vs) ]];
  if (x == null){
    skip
  } else {
    v := [x];
    t := [x + 1];
    if (v == k){
      found := true;
      [[ assert {bind: #beta} (#vs == v :: #beta) ]];
      [[ apply list_member_create(t, #k, #beta) ]]
    } else {
      found := list_member(t, k)
    }
  };
  [[ fold l_member(#vs, k, found) ]];
  [[ fold list(x, #vs) ]];
  return found
}
{ list(#x, #vs) * l_member(#vs, #k, #r) * (ret == #r) }