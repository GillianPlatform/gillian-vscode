@config manual_fold : true

// === Apply tactic ===
//
// In this exercise, we will go through the final tactic you will need: the apply tactic.
//
// In Gillian, sometimes it is not enough to be able to unfold/fold predicates. There are facts
// that are only able to be obtained through induction. This is where lemmas come in!
//
// Lemmas have the following structure: 
//
//     lemma {lemma name} {
//       statement:
//         forall param_1, param_2, ..., param_n.
//            {premises} |- {conclusion}
//     }
//
// And the apply tactic is as follows: 
//
//     [[ apply {lemma name}(param_1, param_2, ..., param_n) ]]. 
//
// The apply tactic will succeed when all premises do in fact hold and are in your proof state. The lemma
// will consume your premises and produce the conclusion on your proof state.
//
// To give a small example, look at the function list_allocate_node. Instead of folding the empty list and then
// folding the list again, we can apply the lemma list_allocate, which takes in as a premise the cell assertion
// (t -> v, null), which we get from the previous two instructions. As such, the lemma can be applied, and indeed
// it allows us to get the postcondition. 
//
// Note that this lemma is not necessary, but in later exercises (and even in this one), you will encounter functions
// that do require lemmas. Lemmas will always be provided for you, and it is not necessary to create new ones.
//
// Knowing this, try to verify list_get and list_member using the lemmas provided to you.
//
// Bonus challenge: can you verify list_get without using the lemma?

lemma list_allocate {
  statement:
    forall t, v. 
      (t -> v, null) |- list(t, [ #v ])
  proof:
    fold list(null, []);
    fold list(t, [ #v ])
}

{ (v == #v) }
function list_allocate_node(v){
  t := new(2);
  [t] := v;
  [[ apply list_allocate(t, v) ]];
  return t
}
{ list(ret, [ #v ]) }

predicate list(+x, vs) {
    (x == null) * (vs == nil);
    (x -> #v, #z) * list(#z, #vss) * (vs == #v::#vss)
}

predicate list_search(+vs, +i, v) {
  (vs == #v :: #vs) * (i == 1) * (v == #v);
  (vs == #v :: #vs) * (i != 1) * (i < len(vs)) * list_search(#vs, i - 1, v)
}

lemma search_not_null {
  statement:
    forall x, vs, i, r.
      list(x, vs) * list_search(vs, i, r) * (i != 0) |- list(x, vs) * list_search(vs, i, r) * (x != null)
  proof:
    unfold list_search(vs, i, r);
    unfold list(x, #vs);
    fold list(x, #vs);
    fold list_search(#vs, #i, #r)
}

{ (x == #x) * (i == #i) * (x != null) * list(x, #vs) * list_search(#vs, #i, #r) }
function list_get(x, i) {
  [[ unfold list(x, #vs)]];
  [[ unfold list_search(#vs, #i, #r)]];
  v := [x];
  next := [x + 1];
  if (i == 1) {
    r := v
  } else {
    i := i - 1;
    [[ assert {bind: #vss} list(next, #vss)]];
    [[ apply search_not_null(next, #vss, i, #r) ]];
    r := list_get(next, i)
  };
  [[ fold list(x, #vs)]];
  [[ fold list_search(#vs, #i, #r)]];
  return r
}
{ list(#x, #vs) * list_search(#vs, #i, #r) * (ret == #r) }

predicate l_member(+vs, +v, r : Bool){
  (vs == []) * (r == false);
  (vs == v :: #ws) * (r == true) * l_member(#ws, v, #mem);
  (vs == #v :: #ws) * (! (#v == v)) * l_member(#ws, v, r)
}

lemma list_member_create {
  statement:
    forall x, k, vs.
      list(x, vs) |- list(x, vs) * l_member(vs, k, #r)
  proof:
    unfold list(x, vs);
    if (x == null) {
      fold list(x, vs);
      fold l_member(vs, k, false)
    } else {
      assert {bind: #v, #vss} (#vs == #v :: #vss) * (x -> #v, #z);
      apply list_member_create(#z, k, #vss);
      if (#v == k) {
        fold l_member(vs, k, true)
      } else {
        fold l_member(vs, k, #r)
      }
    }
}

{ (x == #x) * (k == #k) * list(#x, #vs) }
function list_member(x, k){
  found := false;
  [[ unfold list(x, #vs) ]];
  if (x == null){
    skip
  } else {
    v := [x];
    t := [x + 1];
    if (v == k){
      found := true;
      [[ assert {bind: #vss} (#vs == v :: #vss) ]];
      [[ apply list_member_create(t, #k, #vss) ]]
    } else {
      found := list_member(t, k)
    }
  };
  [[ fold l_member(#vs, k, found) ]];
  [[ fold list(x, #vs) ]];
  return found
}
{ list(#x, #vs) * l_member(#vs, #k, #r) * (ret == #r) }