@config manual_fold : true

// === INTRO ===
//
// In Gillian, predicates are assertions and can be defined recursively.
// The body of the predicate may comprise many cases, which are separated
// by semicolons (;).
//
// One can 'unfold' predicates to expose the body of the predicate. Also,
// if part of the state matches one of the cases of the predicate, then
// one can also 'fold' the predicate. 
// e.g. 
//
// predicate foo(p1, p2, ..., po) {
//   P_1 * P_2 * ... * P_n;
//   Q_1 * Q_2 * ... * Q_m
// }
//
// If we are given the current state as follows:
// { A * (P_1 * P_2 * ... * P_n) * B * C }
// ...then part of the state corresponds to the first case of foo, thus,
// one can fold the predicate and obtain the following state:
// { A * foo(x1, x2, ..., xo) * B * C }
//
// For unfolding, if we are given the current state
// { A * foo(x1, x2, ..., xo) * B * C }
// ...then unfolding generates two branches, one with the following state:
// { A * (P_1 * P_2 * ... * P_n) * B * C }
// ...and the other with the following state:
// { A * (Q_1 * Q_2 * ... * Q_m) * B * C }
//
// Normally, in most cases, Gillian can automatically fold and unfold as needed.
// For clarity, however, this automatic fold/unfold has been disabled for some
// exercises (including this one). You'll have to add these tactics yourself!
// The syntax for folding and unfolding respectively is as follows:
//   [[ fold P(x, y) ]];
//   [[ unfold P(x, y) ]];
//
// Try adding folds and unfolds to make this function verify!
//
// If you get stuck with verifing a function, sometimes hints are in the 
// 'hints' folder

predicate list(+x, vs) {
    (x == null) * (vs == nil);
    (x -> #v, #z) * list(#z, #vss) * (vs == #v::#vss)
}

{ (x == #x) * list(#x, #vs) }
function llen(x) {
    // [[ unfold list(#x, #vs) ]];
    if (x == null) {
        n := 0
    } else {
        t := [x+1];
        n := llen(t);
        n := n + 1
    };
    // [[ fold list(#x, #vs) ]];
    return n
}
{ list(#x, #vs) * (ret == len(#vs)) }
