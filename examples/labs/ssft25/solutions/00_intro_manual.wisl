@config manual_fold : true

// === INTRO ===
//
// Gillian's predicates are *iso-recursive*, meaning that a predicate is not
// considered equivalent to its definition, but can be freely *folded*
// (converted from definition to predicate) and *unfolded* (converted from
// predicate to definition) in one step.
// Normally, in most cases, Gillian can automatically fold and unfold as needed.
// For clarity, however, this automatic fold/unfold has been disabled for some
// exercises (including this one). You'll have to add these tactics yourself!
// The syntax for folding and unfolding respectively is as follows:
//   [[ fold P(x, y) ]];
//   [[ unfold P(x, y) ]];
//
// Try adding folds and unfolds to make this function verify!
//
// If you get stuck with verifing a function, sometimes hints are in the 
// 'hints' folder

predicate list(+x, vs) {
    (x == null) * (vs == nil);
    (x -> #v, #z) * list(#z, #vss) * (vs == #v::#vss)
}

{ (x == #x) * list(#x, #vs) }
function llen(x) {
    // [[ unfold list(#x, #vs) ]];
    if (x == null) {
        n := 0
    } else {
        t := [x+1];
        n := llen(t);
        n := n + 1
    };
    // [[ fold list(#x, #vs) ]];
    return n
}
{ list(#x, #vs) * (ret == len(#vs)) }
