@config manual_fold : true

// ========= List removal new specification =========
//
// Now, suppose that we want to create a new list without the element k instead of 
// doing it inplace. 
//
// Modify the postcondition and the code itself to fit the new specification. 
// Keep in mind to make the postcondition as strong as possible.
//
// You may copy and utilize any functions from the previous exercises

predicate list(+x, vs) {
  (x == null) * (vs == []);
  (x -b> #v, #z) * list(#z, #vss) * (vs == #v :: #vss)
}

predicate list_without(+xs, +ys, +v) {
  (xs == []) * (ys == []);
  (xs == #x :: #xs) * (ys == #x :: #ys) * (v != #x) * list_without(#xs, #ys, v);
  (ys == #y :: #ys) * (#y == v) * list_without(xs, #ys, v)
}

{ (v == #v) }
function list_allocate_node(v){
  t := new(2);
  [t] := v;
  [[ fold list(null, []) ]];
  [[ fold list(t, [ #v ]) ]];
  return t
}
{ list(ret, [ #v ]) }

{ (x == #x) * (k == #k) * list(#x, #vs) }
function list_remove_copy(x, k) {
  [[ unfold list(#x, #vs)]];
  if (x == null) {
    [[ fold list_without([], [], #k) ]];
    [[ fold list(null, [])]];
    r := null
  } else {
    v := [x];
    next := [x + 1];
    if (v == k){
      r := list_remove_copy(next, k); 
      [[ assert {bind: #xs} list(r, #xs) ]];
      [[ fold list_without(#xs, #vs, k)]]
    } else {
      z := list_remove_copy(next, k);
      r := list_allocate_node(v);
      [[ unfold list(r, [ #v ])]];
      [r + 1] := z;
      [[ assert {bind: #zs} list(z, #zs) ]];
      [[ fold list_without(v :: #zs, #vs, k)]];
      [[ fold list(r, v :: #zs)]]
    }
  };
  [[ fold list(x, #vs)]];
  return r
}
{ list(#x, #vs) * list(ret, #nvs) * list_without(#nvs, #vs, #k) }