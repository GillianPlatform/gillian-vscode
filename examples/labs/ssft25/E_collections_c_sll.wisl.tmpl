// ========== Exercise E: Collections-C SLL Library ==========
// 
//
//

// === DON'T EDIT THIS ===
//#region

@config manual_fold : true

predicate sll(+x, alpha, delta) {
    // empty
    (x == null) * (alpha == nil) * (delta == nil);
    // non-empty
    (x -b> #v, #z) * sll(#z, #beta, #gamma) * (alpha == #v::#beta) * (delta == x::#gamma)
}

predicate lseg(+x, +y, alpha, delta) {
  (x == y) * (alpha == nil) * (delta == nil);
  (x -b> #v, #z) * lseg(#z, y, #beta, #gamma) * (alpha == #v::#beta) * (delta == x::#gamma)
}

predicate nounfold cc_sll_ht(+x, h, t, alpha, delta) {
  // Full cc_slist_s object: length, head, tail
  (x -b> 0, h, t) *
  (alpha == []) * (delta == []) *
  (h == null) * (t == null);

  (x -b> #l, #h, #t) *
  (h == #h) * (t == #t) *
  lseg(#h, #t, #beta, #gamma) *
  sll(#t, [ #last ], [ #t ]) *
  (alpha == #beta @ [ #last ]) *
  (delta == #gamma @ [ #t ]) *
  (#l == (len #beta) + 1)
}

predicate cc_sll(+x, alpha, delta) {
  cc_sll_ht(x, #h, #t, alpha, delta)
}

predicate list_nth(+vs, +i : Int, +v) {
  (i == 0) * (vs == v :: #vs) ;
  (i > 0) * (i == (#j + 1)) * (i < len(vs)) * (vs == #v :: #vs) * list_nth(#vs, #j, v)
}

predicate list_count(+vs, +k, n : Int) {
  (vs == []) * (n == 0);
  (vs == k :: #vss) * list_count(#vss, k, #m) * (n == #m + 1);
  (vs == #v :: #vss) * (#v != k) * list_count(#vss, k, n) 
}


lemma lseg_to_sll {
  statement:
    forall x, alpha.
      lseg(x, null, alpha, #delta) |- sll(x, alpha, #delta)
//-  proof: // do later
//-  unfold lseg(x, null, alpha, delta);
//-  if (x != null) {
//-    assert {bind:  #next, #beta, #gamma} (x + 1 -> #next) * lseg(#next, null, #beta, #gamma) ;
//-    apply lseg_to_sll(#next, #beta);
//-    fold sll(x, #alpha)
//-  } else {
//-    fold sll(x, #alpha)
//-  }
}

lemma concat_lseg_sll {
  statement:
    forall x, y, alpha, beta, delta, gamma.
      lseg(x, y, alpha, delta) * sll(y, beta, gamma) |- sll(x, alpha @ beta, delta @ gamma)

//-  proof: // do later
//-    unfold sll(y, beta);
//-    if (y == null) {
//-      apply lseg_to_sll(x, alpha)
//-    } else {
//-      assert (y != null);
//-      unfold sll(y, beta);
//-      assert {bind: #z, #t, #rest} (y -> #z, #t) * sll(#t, #rest) * (beta == #z::#rest);
//-      apply lseg_append(x, y, alpha, #z, #t);
//-      apply concat_lseg_sll(x, #t, alpha @ [ #z ], #rest)
//-    }
}

lemma sll_split_last {
  statement:
    forall x, alpha, last, delta, lastptr.
      sll(x, alpha@[last], delta@[lastptr]) |- lseg(x, lastptr, alpha, delta) * sll(lastptr, [last], [lastptr])
}

lemma lseg_append {
  statement:
    forall x, y, alpha, yval, ynext, delta.
      lseg(x, y, alpha, delta) * (y -b> yval, ynext) |- lseg(x, ynext, alpha @ [ yval ], delta @ [y])

//-  proof:
//-    unfold lseg(x, y, alpha);
//-    if (alpha != []) {
//-      assert {bind: #next, #beta} (x + 1 -> #next) * lseg(#next, y, #beta) ;
//-      apply lseg_append(#next, y, #beta, yval, ynext);
//-      fold lseg(x, ynext, alpha @ [yval])
//-    } else {
//-      fold lseg(x, ynext, alpha @ [yval])
//-    }
}

lemma list_nth_next {
  statement:
    forall xs, ys, v, l, j.
    list_nth(xs @ [v, l] @ ys, j, v) |- list_nth(xs @ [v, l] @ ys, j + 1, l)
}

lemma list_count_create {
  statement:
    forall v, vs, xs, k.
      sll(v, vs, xs) |- sll(v, vs, xs) * list_count(vs, k, #n)
}

lemma list_count_append_true {
  statement:
    forall vs, k, n, v.
      list_count(vs, k, n) * (k == v) |- list_count(vs @ [v], k, n + 1)
}

lemma list_count_append_false {
  statement:
    forall vs, k, n, v.
      list_count(vs, k, n) * (k != v) |- list_count(vs @ [v], k, n)
}

lemma list_nth_next {
  statement:
    forall xs, ys, v, l, j.
    list_nth(xs @ [v, l] @ ys, j, v) |- list_nth(xs @ [v, l] @ ys, j + 1, l)
}


//#endregion
// === EDIT BELOW HERE ===

{ (v == #v) * (i == #i) * cc_sll(#v, #vs, #xs) * (0 <= #i) * (#i < (len #vs)) }
function get_node_at(v, i) {
  size := [v];
  if (i >= size) {
    r := null
  } else {
    head := [v + 1];
    //-[[ assert {bind: #t, #beta, #last, #gamma} (v -> size, head, #t) * lseg(head, #t, #beta, #gamma) * sll(#t, [#last], [#t])]];
    //-[[ assert {bind: #beta, #last, #gamma, #h, #t} 
    //-  (v -b> size, #h, #t) * (#vs == #beta @ [ #last ]) * lseg(#h, #t, #beta, #gamma) *
    //-  (#xs == #gamma @ [#t]) ]];
    //-[[ apply concat_lseg_sll(#h, #t, #beta, [#last], #gamma, [#t]) ]];
    //-[[ unfold sll(head, #beta @ [#last], #gamma @ [#t])]];
    prev := head;
    node := [head + 1];
    val := [head];
    j := 0;
    //-[[ fold lseg(head, prev, [], [])]];
    //-[[ assert {bind: #vss} (#vs == val :: #vss)]];
    //-[[ fold list_nth(#xs, j, prev)]];
    //-[[ fold list_nth(#vs, j, val) ]];
    [[ invariant {bind: prev, node, val, j, #start, #end, #startp, #endp} 
        (i == #i) * (prev -b> val, node) * 
        lseg(head, prev, #start, #startp) * sll(node, #end, #endp) * 
        (#vs == #start @ [val] @ #end) * (#xs == #startp @ [prev] @ #endp) * 
        list_nth(#xs, j, prev) * list_nth(#vs, j, val) *
        ((j - 1) < i) ]];
    while (j < i) {
      assume (node != null);
      //-[[ unfold sll(node, #end, #endp) ]];
      //-[[ apply lseg_append(head, prev, #start, val, node, #startp) ]];
      //-[[ assert {bind: #old} (val == #old) ]];
      //-[[ assert {bind: #oldp} (prev == #oldp) ]];
      prev := node;
      val := [node];
      node := [node + 1];
      //-[[ assert (#end == val :: #beta) ]];
      //-[[ assert (#endp == prev :: #gamma) ]];
      //-[[ apply list_nth_next(#startp, #gamma, #oldp, prev, j) ]];
      //-[[ apply list_nth_next(#start, #beta, #old, val, j) ]];
      j := j + 1
    };
    r := new(3);
    [r] := val;
    [r + 1] := node;
    [r + 2] := prev;
    //-[[ assert {bind: #ys, #zs, #yss, #zss} lseg(#h, prev, #ys, #yss) * sll(node, #zs, #zss)]];
    //-[[ apply lseg_append(#h, prev, #ys, val, node, #yss) ]];
    //-[[ apply concat_lseg_sll(#h, node, #ys@[val], #zs, #yss@[prev], #zss) ]];
    //-[[ assert sll(#h, #beta@[#last], #gamma@[#t] )]];
    //-[[ apply sll_split_last(#h, #beta, #last, #gamma, #t) ]];
    //-[[ assert list_nth(#xs, j, prev) ]]
  };
  return r
}
{ (ret -b> #val, #node, #prev) * cc_sll(#v, #vs, #xs) * list_nth(#xs, #i, #prev) * list_nth(#vs, #i, #val) }


{ (v == #v) * (k == #k) * cc_sll(#v, #vs, #xs) }
function cc_slist_contains(v, k) {
  //-[[ assert {bind: #size} (v -b> #size, #h, #t) ]];
  head := [v + 1];
  node := head;
  count := 0;
  //-[[ if (#size != 0) {
  //-  assert {bind: #beta, #last, #gamma} lseg(head, #t, #beta, #gamma) * sll(#t, [ #last ], [ #t ]);
  //-  apply concat_lseg_sll(#h, #t, #beta, [#last], #gamma, [#t]);
  //-  apply list_count_create(node, #beta @ [#last], #gamma @ [#t], k)
  //-} else {}
  //-]];
  [[ invariant {bind: node, count, #start, #startp, #rg, #end, #endp} 
    lseg(head, node, #start, #startp) * sll(node, #end, #endp) * 
    (#vs == #start @ #end) * (#xs == #startp @ #endp) *
    list_count(#start, k, count) * list_count(#end, k, #rg) ]];
  while (node != null) {
    //-[[ unfold sll(node, #end, #endp) ]];
    //-[[ assert {bind: #node} (node == #node) ]];
    //-[[ unfold list_count(#end, k, #rg) ]];
    val := [node];
    if (val == k) {
      //-[[ apply list_count_append_true(#start, k, count, val) ]];
      count := count + 1
    } else {
      skip
      //-[[ apply list_count_append_false(#start, k, count, val) ]];
    };
    node := [node + 1];
    //-[[ apply lseg_append(head, #node, #start, val, node, #startp) ]]
  };
  
  //-[[ if (#size != 0) {
  //-  apply lseg_to_sll(head, #beta @ [#last]);
  //-  apply sll_split_last(#h, #beta, #last, #gamma, #t)
  //-} else {} ]];
  return count
}
{ cc_sll(#v, #vs, #xs) * list_count(#vs, #k, ret) }
