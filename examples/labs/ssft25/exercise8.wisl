// @config manual_fold : true

// === EXERCISE 8: Assert tactic ===
// TODO: Give a tutorial using list_reverse as an example and let them figure out find_min.


predicate list(+x, alpha) {
    (x == null) * (alpha == nil);
    (x -> #v, #z) * list(#z, #beta) * (alpha == #v::#beta)
}

{ (x == #x) * (y == #y) * list(#x, #vs) * list(#y, [#vy]) }
function list_append_node(x, y) {
  if (x == null) {
    x := y
  } else {
    t := [x + 1];
    z := list_append_node(t, y);
    [x + 1] := z;
  };
  return x
}
{ list(ret, #vs @ [#vy]) }

{ (x == #x) *  list(#x, #vs) }
function list_reverse(x){
  [[ unfold list(x, #vs) ]];
  if (x != null) {
    t := [x + 1];
    [x + 1] := null;
    [[ assert {bind: #v, #beta} (#vs == (#v :: #beta)) ]];
    z := SLL_reverse(t);
    [[ fold list(null, [] )]];
    [[ fold list(x, [ #v ])]];
    y := SLL_append_node(z, x)
  } else {
    y := null;
    [[ fold SLL(y, rev(#vs)) ]]
  };
  return y
}
{ list(ret, rev #vs) }


// TODO: could instead make this list_remove (which also uses asserts) and 
// make them figure out the min predicate.

predicate min(+alpha, v : Int) {
  (alpha == [v]);
  (alpha == #v :: #vs) * (v < #v) * min(#vs, v);
  (alpha == #v :: #vs) * (#v <= #min) * min(#vs, #min) * (v == #v)
}

{ (x == #x) * (x != null) * list(x, #alpha) }
function find_min(x) {
  [[ unfold list(x, #alpha) ]];
  val := [x];
  assume_type(val, Int); // TODO: change this to the new type assertion
  next := [x + 1];
  if (next == null) {
    [[ assert {bind: #beta} list(next, #beta) ]];
    [[ unfold list(next, #beta) ]];
    r := val;
    [[ fold list(null, [])]]
  } else {
    r := find_min(next, val);
    if (val <= r) {
      r := val
    } else {
      skip
    }
  };
  [[ fold min(#alpha, r) ]];
  [[ fold list(x, #alpha) ]];
  return r
}
{ list(#x, #alpha) * min(#alpha, #r) * (ret == #r)}