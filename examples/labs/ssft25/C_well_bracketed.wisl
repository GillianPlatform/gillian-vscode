@config manual_fold : true

// === Exercise C : Well-bracked function ===

// Having worked with singly-linked lists, it is now time to work with an application of it. 

// TODO: put a description of what well-bracketed means. We can decide later if we want them to figure out the predicate
// or just figure out how to verify the function itself. Can also partially give the predicate and let them figure out the rest.

predicate list(+x, vs) {
  // Empty list
  (x == null) * (vs == []);
  // One list node and the rest
  (x -b> #v, #next) * list(#next, #vs) *
  (vs == #v :: #vs)
}

{ (v == #v) }
function list_allocate_node(v) {
  t := new(2);
  [t] := v;
  return t
}
{ list(ret, [ #v ]) }

{ (x == #x) * (k == #k) * list(#x, #vs) }
function list_push(x, k) {
  z := list_allocate_node(k);
  [z + 1] := x;
  return z
}
{ list(ret, #k :: #vs) }

{ (x == #x) * (x != null) * list(#x, #k :: #vs) }
function list_pop(x) {
  r := new(2);
  k := [x];
  z := [x + 1];
  [r] := k;
  [r + 1] := z;
  return r
}
{ list(#z, #vs) * (ret == #r) * #r -b> #k, #z }

// Well bracked predicates

predicate ob(+c : String) {
  ((c == "<") || (c == "["))
}

predicate cb(+c : String) {
  ((c == ">") || (c == "]"))
}

predicate nb(+c : String) {
  ((c != "<") /\ (c != ">") /\ (c != "[") /\ (c != "]"))
}

predicate wbs(+a, +b, r : Bool) {
  (a == []) * (b == []) * (r == true)
}

predicate wb(+a, r : Bool) {
  wbs(a, [], r)
}

{ (x == #x) * (s == #s) * list(#x, #a) * list(#s, #b) * wbs(#a, #b, #r) }
function wellBr_helper(x, s) {
  ok := true;
  if (x == null) {
    if (s != null) {
      ok := false
    } else {
      skip
    }
  } else {
    c := [x];
    n := [x + 1];
    if ((c == "<") || (c == "[")) {
      s := list_push(s, c);
      ok := wellBr_helper(n, s)
    } else {
      if ((c == ">") || (c == "]")) {
        if (s == null) {
          ok := false
        } else {
          r := list_pop(s);
          d := [r];
          s := [r + 1];
          bpair := ((d == "<") && (c == ">")) || ((d == "[") && (c == "]"));
          ok := wellBr_helper(n, s);
          ok := ok && bpair
        }
      } else {
        ok := wellBr_helper(n, s)
      }
    }
  };
  return ok
}
{ list(#x, #a) * wbs(#a, #b, #r) * (ret == #r) }

{ (x == #x) * list(x, #a) * wb(#a, #r) }
function wellBr(x) {
  s := null;
  r := wellBr_helper(x, s);
  return r
}
{ list(#x, #a) * wb(#a, #r) * (ret == #r) }