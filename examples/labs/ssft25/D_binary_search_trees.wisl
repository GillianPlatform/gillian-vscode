@config manual_fold : false
// === EXERCISE D : binary search trees ===
// 
// In this exercise, we go through a more interesting
// data structure. In particular, we go through a
// binary search tree.

// The binary search tree comprises a number of
// components:
//   1. key (which is an Int value for this exercise)
//   2. left subtree
//   3. right subtree
// All keys in the left subtree must be less than the key,
// and all keys in the right subtree must be greater than
// the key. This restriction implies there are no 
// duplicate keys in any given binary search tree.

// === PREDICATES ===
//
// Before setting up the binary search tree
// predicate, we must be able to express the following
// properties:
//   1. There are no duplicate key elements in a tree
//   2. All keys in the left subtree are strictly less
//      than the key on the root tree
//   3. All keys in the right subtree are strictly
//      greater than the key on the root tree.
// There are many ways to express this property -- but
// for this exercise, we will express these using
// lists.  

// TODO: Remove this and introduce a pure predicate instead
predicate isInt(v : Int) {
  emp
}

// We have the list_member predicate, which should be
// familiar from the singly-linked list exercises.
predicate list_member(+vs, +v, r : Bool){
  (vs == []) * (r == false);
  (vs == v :: #rest) * (r == true);
  (vs == #v :: #rest) * (#v != v) * list_member(#rest, v, r)
}

// We also have the list_gt and list_lt predicates.
// list_lt(vs, v) states v < v' for all v' ∈ vs
// list_gt(vs, v) states v > v' for all v' ∈ vs
predicate list_gt(+vs, +v : Int){
  (vs == []);
  (vs == #v :: #rest) * (#v < v) * list_gt(#rest, v)
}

predicate list_lt(+vs, +v : Int){
  (vs == []);
  (vs == #v :: #rest) * (#v > v) * list_lt(#rest, v)
}

// ...and now we have the bst predicate.
// In the base case, we have the empty tree.
// In the inductive case, we have the following:
//   - x -b> #v, #l, #r
//     a ternary cell predicate, where
//     + #v is the key
//     + #l points to the left subtree
//     + #r points to the right subtree
//   - bst(#l, #vsl), the left subtree
//   - bst(#r, #vsr), the right subtree
//   - vs == #vsl @ [#v] @ #vsr
//     the 'keys' in the binary search tree pointed
//     by x, where
//     + #v is the key
//     + #vsl is the list of keys in subtree pointed
//       by #l,
//     + #vsr is the list of keys in subtree pointed
//       by #r
//   - list_member(#vsl, #v, false)
//     a predicate stating that duplicates of #v
//     cannot exist in subtree pointed by #l
//   - list_member(#vsr, #v, false)
//     same as above for the right subtree
//   - list_gt(#vsl, #v), a predicate stating that
//     that the key #k is strictly greater than all
//     keys in the subtree pointed by #l
//   - list_gt(#vsr, #v), a predicate stating that
//     that the key #k is strictly less than all
//     keys in the subtree pointed by #r
predicate bst(+x, vs : List) {
  // Empty Node
  (x == null) * (vs == []);
  (x -b> #v, #l, #r) * bst(#l, #vsl) * bst(#r, #vsr) *
  (vs == (#vsl @ [#v] @ #vsr)) *
  list_member(#vsl, #v, false) * 
  list_member(#vsr, #v, false) *
  list_gt(#vsl, #v) *
  list_lt(#vsr, #v)
}

// We also have a predicate list_min, which states
// given list_min(vs, v), v <= v' for all v' ∈ vs
// This might be better thought of as list_lte,
// i.e. the element v is less than or equal to all
// elements in vs. This is not used for the binary
// search tree predicate but is used elsewhere.
predicate list_min(+vs, +v : Int){
  (vs == []);
  (vs == #v :: #rest) * (v <= #v) * list_min(#rest, v)
}

// === LEMMAS ===
// We do not go through the lemmas in great detail,
// but we provide a number of lemmas that you may
// find useful for the purpose of completing this
// exercise.

lemma list_member_prepend_neq {
  statement:
    forall vs, k, v.
      list_member(vs, v, #r) * (k != v) |- list_member(k::vs, v, #r)
}

lemma list_member_concat {
  statement:
    forall vs1, vs2, v.
      list_member(vs1, v, true) |- list_member(vs1 @ vs2, v, true)
}

lemma list_member_concat_gen {
  statement:
    forall vs1, vs2, v.
      list_member(vs1, v, #r1) * list_member(vs2, v, #r2) |- list_member(vs1 @ vs2, v, (#r1 || #r2))
}

// Note: lemmas with emp as an assumption essentially
//       implies the lemma does not have an assumption
lemma list_member_front_helper {
  statement:
    forall v, vs.
      emp |- list_member(v::vs, v, true)
}

lemma list_member_mid {
  statement:
    forall v, vsl, vsr.
      emp |- list_member(vsl @ [v] @ vsr, v, true)
}

lemma min_merge {
  statement:
    forall min, vsl, vsr.
      list_min(vsl, min) * list_lt(vsr, min) |- list_min(vsl@vsr, min) * list_lt(vsr, min)
}

lemma min_merge_k {
  statement:
    forall min, k, vsl, vsr.
      list_min(vsl@[k], min) * list_lt(vsr, k) |- list_min(vsl@[k]@vsr, min) * list_lt(vsr, k)
}

lemma min_gt_append {
  statement:
    forall min, k, vs.
      list_min(vs, min) * list_gt(vs, k) * (vs != []) |- list_min(vs @ [k], min) * list_gt(vs, k)
}

lemma min_include {
  statement:
    forall k, vs.
      list_min(vs, k) |- list_min(k::vs, k)
}

// Note: pure predicates can be duplicated -- you may
// find a number of these 'duplicate' lemmas useful
// before folding a predicate and consuming the pure
// predicates.
lemma min_duplicate {
  statement:
    forall vs, k.
      list_min(vs, k) |- list_min(vs, k) * list_min(vs, k)
}

lemma lt_duplicate {
  statement:
    forall vs, k.
      list_lt(vs, k) |- list_lt(vs, k) * list_lt(vs, k)
}

lemma gt_duplicate {
  statement:
    forall vs, k.
      list_gt(vs, k) |- list_gt(vs, k) * list_gt(vs, k)
}

lemma member_duplicate {
  statement:
    forall vs, k, r.
      list_member(vs, k, r) |- list_member(vs, k, r) * list_member(vs, k, r)
}

lemma list_member_gt {
  statement:
    forall a, k, vs.
      (k < a) * list_gt(vs, k) |- list_member(vs, a, false) * list_gt(vs, k)
}

lemma list_member_lt {
  statement:
    forall a, k, vs.
      (a < k) * list_lt(vs, k) |- list_member(vs, a, false) * list_lt(vs, k)
}


// 00. creating a BST with a single element (EASY)
//     This function is analogous to 
//     SLLAlocateNode, but it will be more
//     involved due to the fact that there
//     are more predicates you need to fold.
{ (v == #v) * isInt(v) }
function BSTAllocateLeaf(v) {
  t := new(3);
  [t] := v;
  return t
}
{ bst(ret, [#v]) }

// 01. copying a binary search tree (MEDIUM)
//     This function creates a copy of a given
//     binary search tree.
{ (x == #x) * bst(#x, #vs) }
function BSTCopy(x) {
  if(x != null) {
    y := new(3);
    t := [x];
    [y] := t;
    t := [x + 1];
    t := BSTCopy(t);
    [y + 1] := t;
    t := [x + 2];
    t := BSTCopy(t);
    [y + 2] := t
    // Hint 1, 2
  } else {
    y := null
  };
  return y
}
{ bst(#x, #vs) * bst(ret, #vs) }

// 02. Searching for a value in a BST (MEDIUM)
{ (x == #x) * (a == #a) * bst(#x, #vs) * isInt(a) }
function BSTSearch(x, a) {
  r := false;
  if(x != null) {
    // Hint 3
    t := [x];
    if(a == t) {
      // Hint 4
      r := true
    } else {
      if(a < t) {
        // Hint 5
        t := [x + 1];
        r := BSTSearch(t, a)
      } else {
        // Hint 5
        t := [x + 2];
        r := BSTSearch(t, a)
      }
    }
  } else {
    skip
  };
  [[ fold bst(#x, #vs) ]];
  return r
}
{ bst(#x, #vs) * list_member(#vs, #a, ret) }

// 02. obtaining the minimum of a binary search tree (HARD)
//     This function returns the minimum key in a
//     given binary serach tree. In other words,
//     the function returns the left-most key in the
//     tree. Note that the precondition states the 
//     given tree is non-empty.
{ (x == #x) * (#x != null) * bst(#x, #vs) }
function BSTFindMin(x) {
  // Hint 6
  l := [x + 1];
  if (l == null) {
    min := [x]
    // Hint 7
  } else {
    min := BSTFindMin(l)
    // Hint 8, 9
  };
  return min
}
{ (#x != null) * bst(#x, #vs) * list_member(#vs, ret, true) * list_min(#vs, ret) }
