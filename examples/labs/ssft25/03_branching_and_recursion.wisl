@config manual_fold : true

// === Dealing with Ifs and Recursion ===
// Using the same predicate, solve the following functions that deal with recursively going into the list.

// TODO: write more about how gillian works in this case? Or maybe this is already covered.

predicate list(+x, alpha) {
    (x == null) * (alpha == nil);
    (x -> #v, #z) * list(#z, #beta) * (alpha == #v::#beta)
}

// TODO: make this admitted/not shown to the user
{ (v == #v) }
function list_allocate_node(v){
  t := new(2);
  [t] := v;
  return t
}
{ list(ret, [ #v ]) }

{(x == #x) * (y == #y) * list(#x, #vx) * list(#y, #vy) }
function list_concat(x, y) {
  // [[ unfold list(x, #vx) ]];
  if (x == null){
    x := y
  } else {
    t := [x + 1];
    z := list_concat(t, y);
    [x + 1] := z
    // [[ fold list(x, #vx @ #vy) ]]
  };
  return x
}
{ list(ret,  #vx @ #vy) }

{ (x == #x) * list(#x, #vs) }
function list_copy(x){
  y := null;
  // [[ unfold list(x, #vs) ]];
  if (x != null) {
    k := [x];
    y := list_allocate_node(k);
    // [[ unfold list(y, [ k ]) ]];
    t := [x + 1];
    z := list_copy(t);
    [y + 1] := z
  } else {
    skip
  };
  // [[ fold list(x, #vs) ]];
  // [[ fold list(y, #vs) ]];
  return y
}
{ list(#x, #vs) * list(ret, #vs) }