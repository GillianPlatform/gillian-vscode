@config manual_fold : true
predicate sll(+x, alpha, delta) {
    // empty
    (x == null) * (alpha == nil) * (delta == nil);
    // non-empty
    (x -b> #v, #z) * sll(#z, #beta, #gamma) * (alpha == #v::#beta) * (delta == x::#gamma)
}

predicate lseg(+x, +y, alpha, delta) {
  (x == y) * (alpha == nil) * (delta == nil);
  (x -b> #v, #z) * lseg(#z, y, #beta, #gamma) * (alpha == #v::#beta) * (delta == x::#gamma)
}

predicate cc_sll_ht(+x, +h, +t, alpha, delta) {
  // Full cc_slist_s object: length, head, tail
  (x -b> 0, h, t) *
  (alpha == []) * (delta == []) *
  (h == null) * (t == null);

  (x -b> #l, h, t) *
  (h == #h) * (t == #t) *
  lseg(#h, #t, #beta, #gamma) *
  sll(#t, [ #last ], [ #t ]) *
  (alpha == #beta @ [ #last ]) *
  (delta == #gamma @ [ #t ]) *
  (#l == (len #beta) + 1)
}

predicate cc_sll(+x, alpha, delta) {
  cc_sll_ht(x, #h, #t, alpha, delta)
}

lemma lseg_to_sll {
  statement:
    forall x, alpha.
      lseg(x, null, alpha, delta) |- sll(x, alpha, delta)

  proof: // do later
    unfold lseg(x, null, alpha, delta);
    if (x != null) {
      assert {bind:  #next, #beta, #gamma} (x + 1 -> #next) * lseg(#next, null, #beta, #gamma) ;
      apply lseg_to_sll(#next, #beta);
      fold sll(x, #alpha)
    } else {
      fold sll(x, #alpha)
    }
}

lemma concat_lseg_sll {
  statement:
    forall x, y, alpha, beta, delta, gamma.
      lseg(x, y, alpha, delta) * sll(y, beta, gamma) |- sll(x, alpha @ beta, delta @ gamma)

  proof: // do later
    unfold sll(y, beta);
    if (y == null) {
      apply lseg_to_sll(x, alpha)
    } else {
      assert (y != null);
      unfold sll(y, beta);
      assert {bind: #z, #t, #rest} (y -> #z, #t) * sll(#t, #rest) * (beta == #z::#rest);
      apply lseg_append(x, y, alpha, #z, #t);
      apply concat_lseg_sll(x, #t, alpha @ [ #z ], #rest)
    }
}

lemma sll_split_last {
  statement:
    forall x, alpha, last, delta, lastptr.
      sll(x, alpha@[last], delta@[lastptr]) |- lseg(x, lastptr, alpha, delta) * sll(lastptr, [last], [lastptr])
}

lemma lseg_append {
  statement:
    forall x, y, alpha, yval, ynext, delta.
      lseg(x, y, alpha, delta) * (y -b> yval, ynext) |- lseg(x, ynext, alpha @ [ yval ], delta @ [y])

  proof:
    unfold lseg(x, y, alpha);
    if (alpha != []) {
      assert {bind: #next, #beta} (x + 1 -> #next) * lseg(#next, y, #beta) ;
      apply lseg_append(#next, y, #beta, yval, ynext);
      fold lseg(x, ynext, alpha @ [yval])
    } else {
      fold lseg(x, ynext, alpha @ [yval])
    }
}

predicate list_nth(+vs, +i : Int, +v) {
  (i == 0) * (vs == v :: #vs) ;
  (i > 0) * (i == (#j + 1)) * (i < len(vs)) * (vs == #v :: #vs) * list_nth(#vs, #j, v)
}

{ (v == #v) * (i == #i) *  cc_sll(#v, #vs, #xs) * (0 <= #i) * (#i < (len #vs)) }
function get_node_at(v, i, n) {
    size := [v];
    if (i >= size) {
        r := null
    } else {
      head := [v + 1];
      [[ assert {bind: #t, #beta, #last, #gamma} (v -> size, head, #t) * lseg(head, #t, #beta, #gamma) * sll(#t, [#last], [#t])]];
      [[ assert {bind: #beta, #last, #gamma, #h, #t} 
        (v -> size, #h, #t) * (#vs == #beta @ [ #last ]) * lseg(#h, #t, #beta, #gamma) *
        (#xs == #gamma @ [#t]) ]];
      [[ apply concat_lseg_sll(#h, #t, #beta, [#last], #gamma, [#t]) ]];
      [[ unfold sll(head, #beta @ [#last], #gamma @ [#t])]];
      prev := head;
      node := [head + 1];
      val := [head];
      j := 0;
      [[ fold lseg(head, prev, [], [])]];
      [[ assert {bind: #vss} (#vs == val :: #vss)]];
      [[ fold list_nth(#xs, j, prev)]];
      [[ invariant {bind: prev, node, val, j, #start, #end, #startp, #endp} 
          (i == #i) * (prev -b> val, node) * 
          lseg(head, prev, #start, #startp) * sll(node, #end, #endp) * 
          (#vs == #start @ [val] @ #end) * (#xs == #startp @ [prev] @ #endp) * 
          list_nth(#xs, j, prev) * 
          ((j - 1) < i) ]];
      while (j < i) {
        assume (node != null);
        [[ unfold sll(node, #end, #endp) ]];
        [[ apply lseg_append(head, prev, #start, val, node, #startp) ]];
        [[ assert {bind: #old} (val == #old) ]];
        [[ assert {bind: #oldp} (prev == #oldp) ]];
        prev := node;
        val := [node];
        node := [node + 1];
        [[ assert (#end == val :: #beta) ]];
        [[ assert (#endp == prev :: #gamma) ]];
        [[ apply a(#startp, #gamma, #oldp, prev, j) ]];
        j := j + 1
      };
      r := new(3);
      [r] := val;
      [r + 1] := node;
      [r + 2] := prev;
      [[ assert {bind: #ys, #zs, #yss, #zss} lseg(#h, prev, #ys, #yss) * sll(node, #zs, #zss)]];
      [[ apply lseg_append(#h, prev, #ys, val, node, #yss) ]];
      [[ apply concat_lseg_sll(#h, node, #ys@[val], #zs, #yss@[prev], #zss) ]];
      [[ assert sll(#h, #beta@[#last], #gamma@[#t] )]];
      [[ apply sll_split_last(#h, #beta, #last, #gamma, #t) ]];
      [[ assert list_nth(#xs, j, prev) ]]
    };
    return r
}
{ (ret -b> #val, #node, #prev) * cc_sll(#v, #vs, #xs) * list_nth(#xs, #i, #prev) }

lemma a {
  statement:
    forall xs, ys, v, l, j.
    list_nth(xs @ [v, l] @ ys, j, v) |- list_nth(xs @ [v, l] @ ys, j + 1, l)
}